package classes.noteskin
{
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.geom.Rectangle;
    import flash.geom.Point;
    import classes.engine.track.TrackConfigGroup;
    import classes.engine.track.TrackConfigLane;
    import flash.geom.Matrix;

    public class EmbedNoteskinBase
    {
        /** Static Helper Point for Bitmap Generation */
        private static const BASE_POINT:Point = new Point(0, 0);

        /** Static Helper for Cache Generation */
        private static var BASE_BITMAP:Bitmap = new Bitmap(null);

        /** Max Number to known colors, if changed, update INDEXES and COLOR_INDEXES with new values. */
        public static const COLOR_COUNT:int = 9;

        /** Sprite Name to Vector Index lookup table. */
        public static const INDEXES:Object = {
                "receptor": 0, 
                "note_blue": 1,
                "note_red": 2,
                "note_green": 3,
                "note_yellow": 4,
                "note_pink": 5,
                "note_purple": 6,
                "note_orange": 7,
                "note_cyan": 8,
                "note_white": 9
            };

        /** Note Color to Hash Lookup Table */
        public static const COLOR_INDEXES:Object = {
                "blue": 0,
                "red": 1,
                "green": 2,
                "yellow": 3,
                "pink": 4,
                "purple": 5,
                "orange": 6,
                "cyan": 7,
                "white": 8
            };

        /** Marks a Noteskin as Valid and contains useable sprite data. */
        public var valid:Boolean = false;

        /** Apply Lane Ratation to images on cache creation. */
        public var useNoteRotation:Boolean = true;

        /**
         * Vector list of Sprite BitmapData for the noteskin, with the following indexes:
         * 0: receptor 
         * 1: blue 
         * 2: red 
         * 3: green 
         * 4: yellow 
         * 5: pink 
         * 6: purple 
         * 7: orange 
         * 8: cyan 
         * 9: white 
         */
        public var images:Vector.<BitmapData>;
        
        /**
         * Initilize the noteskin, should be override to make a call to processData
         * with the embedded resources.
         */
        public function init():void
        {
            // Overwrite in class extensions.
        }

        /**
         * Process the JSON and Bitmap inputs to generate a valid bitmap noteskin. This can be override by a single noteskin 
         * if the format is different from the expected Phaser JSON input.
         * 
         * @param json  JSON formatted for spritesheet, using the Phaser specification generated by TexturePacker
         * @param bmp   Bitmap of the source noteskin spritesheet, used to generate the per-sprite images.
         */
        public function processData(json:String, bmp:Bitmap):void
        {
            images = new Vector.<BitmapData>(10, true);

            var bmd:BitmapData = bmp.bitmapData;
            var jsonData:Object = JSON.parse(json);
            var frameData:Object = jsonData["frames"];

            // Check for basic inclusion of required sprites.
            if(frameData["note_blue"] == null || frameData["receptor"] == null)
                return;

            // Copy Sprites from Spritesheet.
            var imageFrame:Object;
            var note_canvas:BitmapData;
            for (var image:String in frameData)
            {
                if(INDEXES[image] == null)
                    continue;

                imageFrame = frameData[image]["frame"];
                note_canvas = new BitmapData(imageFrame["w"], imageFrame["h"], true, 0);
                note_canvas.copyPixels(bmd, new Rectangle(imageFrame["x"], imageFrame["y"], imageFrame["w"], imageFrame["h"]), BASE_POINT, null, null, true);

                images[INDEXES[image]] = note_canvas;
            }

            // Fill missing entries from sheet.
            for(var i:int = 2; i < images.length; i++)
                if(images[i] == null)
                    images[i] = images[1];

            // Mark as Valid.
            valid = true;
        }

        /**
         * Fills the provided output vector with precalculated bitmaps for all notes direction and colors.
         * @param trackData Reference trackdata to build cache for.
         * @param output Premade output vector to fill with bitmaps, using a simple index.
         */
        public function buildCache(trackData:TrackConfigGroup):Vector.<BitmapData>
        {
            var directions:int = trackData.lane_order.length;

            var output:Vector.<BitmapData> = new Vector.<BitmapData>(directions * 9, true);

            var rect:Rectangle = new Rectangle(0, 0, 64, 64);
            var matrix:Matrix = new Matrix();

            var laneGroupDown:TrackConfigLane = trackData.track_lanes["down"];
            var laneGroup:TrackConfigLane;
            var hashIndex:int;
            var sourceBitmap:BitmapData;
            var cacheBitmap:BitmapData;

            for each(var trackID:String in trackData.lane_order)
            {
                laneGroup = trackData.track_lanes[trackID];

                for(var color:int = 0; color < 9; color++)
                {
                    hashIndex = laneGroup.index + color * directions;
                    sourceBitmap = images[color];

                    rect.width = sourceBitmap.width;
                    rect.height = sourceBitmap.height;

                    // Reset Matrix, Offset to center of Bitmap, Rotate, Offset Back.
                    matrix.a = matrix.d = 1;
                    matrix.b = matrix.c = matrix.tx = matrix.ty = 0;
                    matrix.translate(-(rect.left + (rect.width / 2)), -(rect.top + (rect.height / 2)));
                    matrix.rotate(useNoteRotation ? laneGroup.rotation : laneGroupDown.rotation);
                    matrix.translate(rect.left + (rect.width / 2), rect.top + (rect.height / 2));

                    // Determine Result Size for Bitmap
                    BASE_BITMAP.bitmapData = sourceBitmap;
                    BASE_BITMAP.rotation = useNoteRotation ? laneGroup.rotation_deg : laneGroupDown.rotation_deg;

                    // Create Cache bitmap data.
                    cacheBitmap = new BitmapData(BASE_BITMAP.width, BASE_BITMAP.height, true, 0x00000000)
                    cacheBitmap.draw(sourceBitmap, matrix);
                    output[hashIndex] = cacheBitmap;
                }
            }

            BASE_BITMAP.bitmapData = null;

            return output;
        }

        /**
         * Gets the noteskin name, if it isn't override it will return the 
         * name of the class that was used to generate it.
         * @return Name of the noteskin.
         */
        public function getName():String {
            var t:String = (Object(this).constructor).toString();
			return t.substr(7, t.length - 8);
        }
    }
}